{
  "hash": "962bb71b8b53244dae3b15bd70e8bbd4",
  "result": {
    "markdown": "# Matching {#sec-ex-matching}\n\n\n\n\n\nTo perform matching, we'll use the `MatchIt` package, which provides an interface to many forms of matching and allows for specification of many different options to customize the matching. The `MatchIt` [documentation](https://kosukeimai.github.io/MatchIt/index.html) includes extensive examples and vignettes that should be used to supplement the example here. Much of the information here is simply lifted from this documentation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"MatchIt\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'MatchIt'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:cobalt':\n\n    lalonde\n```\n:::\n:::\n\n\nFor matching, we'll focus on the ATT, though it is possible for some matching methods to target the ATE as well. The simplest method of matching is 1:1 nearest neighbor propensity score matching, which is the default using `matchit()`. For more details on this procedure, including effect estimation, see the `MatchIt` documentation and vignettes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#1:1 NN propensity score matching w/o replacement\nm1 <- matchit(RHC ~ aps1 + meanbp1 + pafi1 + crea1 + hema1 +\n                paco21 + surv2md1 + resp1 + card + edu +\n                age + race + sex, data = rhc)\nm1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA matchit object\n - method: 1:1 nearest neighbor matching without replacement\n - distance: Propensity score\n             - estimated with logistic regression\n - number of obs.: 5735 (original), 4368 (matched)\n - target estimand: ATT\n - covariates: aps1, meanbp1, pafi1, crea1, hema1, paco21, surv2md1, resp1, card, edu, age, race, sex\n```\n:::\n:::\n\n\nWe can use `summary()` in `MatchIt` to assess balance, but we'll stick with `cobalt`. We can just supply the `matchit` object to `bal.tab()`, which contains the treatment and covariate information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbal.tab(m1, stats = c(\"m\", \"ks\"), binary = \"std\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBalance Measures\n               Type Diff.Adj KS.Adj\ndistance   Distance   0.3765 0.2060\naps1        Contin.   0.2109 0.1103\nmeanbp1     Contin.  -0.1447 0.0728\npafi1       Contin.  -0.1650 0.0907\ncrea1       Contin.   0.1296 0.1282\nhema1       Contin.  -0.0494 0.0614\npaco21      Contin.  -0.0699 0.0453\nsurv2md1    Contin.  -0.1087 0.0710\nresp1       Contin.  -0.1003 0.0755\ncard_Yes     Binary   0.1270 0.0627\nedu         Contin.   0.0307 0.0343\nage         Contin.  -0.0291 0.0682\nrace_white   Binary   0.0000 0.0000\nrace_black   Binary   0.0038 0.0014\nrace_other   Binary  -0.0056 0.0014\nsex_Male     Binary   0.0362 0.0179\n\nSample sizes\n          Control Treated\nAll          3551    2184\nMatched      2184    2184\nUnmatched    1367       0\n```\n:::\n:::\n\n\nAlthough balanced improved, we still have covariates with unacceptable imbalance, and it is possible to do much better than simple 1:1 matching. @connorsEffectivenessRightHeart1996a used matching with a caliper on the propensity score; here we'll do so as well, setting a caliper of .2 standard deviations of the logit of the propensity score, which is an arbitrary but often used caliper width:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2 <- matchit(RHC ~ aps1 + meanbp1 + pafi1 + crea1 + hema1 +\n                paco21 + surv2md1 + resp1 + card + edu +\n                age + race + sex, data = rhc,\n              link = \"linear.logit\", caliper = .2)\nm2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA matchit object\n - method: 1:1 nearest neighbor matching without replacement\n - distance: Propensity score [caliper]\n             - estimated with logistic regression and linearized\n - caliper: <distance> (0.2)\n - number of obs.: 5735 (original), 3868 (matched)\n - target estimand: ATT\n - covariates: aps1, meanbp1, pafi1, crea1, hema1, paco21, surv2md1, resp1, card, edu, age, race, sex\n```\n:::\n\n```{.r .cell-code}\nbal.tab(m1, stats = c(\"m\", \"ks\"), binary = \"std\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBalance Measures\n               Type Diff.Adj KS.Adj\ndistance   Distance   0.3765 0.2060\naps1        Contin.   0.2109 0.1103\nmeanbp1     Contin.  -0.1447 0.0728\npafi1       Contin.  -0.1650 0.0907\ncrea1       Contin.   0.1296 0.1282\nhema1       Contin.  -0.0494 0.0614\npaco21      Contin.  -0.0699 0.0453\nsurv2md1    Contin.  -0.1087 0.0710\nresp1       Contin.  -0.1003 0.0755\ncard_Yes     Binary   0.1270 0.0627\nedu         Contin.   0.0307 0.0343\nage         Contin.  -0.0291 0.0682\nrace_white   Binary   0.0000 0.0000\nrace_black   Binary   0.0038 0.0014\nrace_other   Binary  -0.0056 0.0014\nsex_Male     Binary   0.0362 0.0179\n\nSample sizes\n          Control Treated\nAll          3551    2184\nMatched      2184    2184\nUnmatched    1367       0\n```\n:::\n:::\n\n\nWe can see that several treated units were discarded, which changes the estimand, though we do see major improvements in balance. There are many methods we can try to improve balance while retaining the estimand, but we'll use generalized full matching [@savjeGeneralizedFullMatching2021] by setting `method = \"quick\"`, which is fast and tends to perform well in a variety of settings[^ex-match-1].\n\n[^ex-match-1]: Optimal full matching (`method = \"full\"`) tends to work a bit better, but can be much slower for larger datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 <- matchit(RHC ~ aps1 + meanbp1 + pafi1 + crea1 + hema1 +\n                paco21 + surv2md1 + resp1 + card + edu +\n                age + race + sex, data = rhc,\n              method = \"quick\")\nm3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA matchit object\n - method: Generalized full matching\n - distance: Propensity score\n             - estimated with logistic regression\n - number of obs.: 5735 (original), 5735 (matched)\n - target estimand: ATT\n - covariates: aps1, meanbp1, pafi1, crea1, hema1, paco21, surv2md1, resp1, card, edu, age, race, sex\n```\n:::\n\n```{.r .cell-code}\nbal.tab(m3, stats = c(\"m\", \"ks\"), binary = \"std\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBalance Measures\n               Type Diff.Adj KS.Adj\ndistance   Distance  -0.0001 0.0050\naps1        Contin.  -0.0260 0.0192\nmeanbp1     Contin.  -0.0124 0.0294\npafi1       Contin.  -0.0309 0.0355\ncrea1       Contin.  -0.0505 0.0576\nhema1       Contin.   0.0203 0.0626\npaco21      Contin.   0.0044 0.0231\nsurv2md1    Contin.   0.0341 0.0403\nresp1       Contin.  -0.0392 0.0684\ncard_Yes     Binary  -0.0516 0.0255\nedu         Contin.  -0.0154 0.0239\nage         Contin.  -0.0347 0.0652\nrace_white   Binary   0.0287 0.0118\nrace_black   Binary   0.0017 0.0006\nrace_other   Binary  -0.0506 0.0125\nsex_Male     Binary   0.0178 0.0088\n\nSample sizes\n                     Control Treated\nAll                  3551.      2184\nMatched (ESS)        1017.28    2184\nMatched (Unweighted) 3551.      2184\n```\n:::\n:::\n\n\nBalance is good and we retained the target estimand, but generalized full matching took a tool on the effective sample size (ESS) of our control group, which is now around 1000 (from around 3500). Even though generalized full matching retains the entire sample (i.e., not a single unit is dropped), the matching weights resulting from it have variability such that the ESS is much lower than the original sample size. There are ways to manage the balance-ESS trade-off that are specific to each matching method.\n\nAlthough balance isn't perfect and could be improved with additional fine-tuning, we'll move forward with this matched sample to demonstrate effect estimation and reporting. First, we need to extract the matched sample from the `matchit` object using `match.data()`. This adds columns to the original dataset called `\"distance\"`, `\"weights\"`, and `\"subclass\"` containing the propensity score, matching weights, and matched strata (i.e., pair membership). When units are dropped in the matching (e.g., when using 1:1 matching), the output will only contain the units remaining in the matched sample[^ex-match-2].\n\n[^ex-match-2]: Note that this behavior, and the names of the new columns created, can be customized by the user.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmd <- match.data(m3)\n\n# Names of new dataset; note the three new variables at the end\nnames(md)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"aps1\"     \"meanbp1\"  \"pafi1\"    \"crea1\"    \"hema1\"    \"paco21\"  \n [7] \"surv2md1\" \"resp1\"    \"card\"     \"edu\"      \"age\"      \"race\"    \n[13] \"sex\"      \"RHC\"      \"death\"    \"distance\" \"weights\"  \"subclass\"\n```\n:::\n:::\n\n\nTo estimate the treatment effect, we need to proceed in two steps. First, we fit the outcome model to the matched sample including the matching weights. Second, we compute the treatment effect using g-computation. Our estimand will be the marginal risk ratio for the treated units (i.e., the ATT on the risk ratio scale). We will fit a logistic regression for the outcome, including covariates and their interactions with treatment in the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- glm(death ~ RHC * (aps1 + meanbp1 + pafi1 + crea1 + hema1 +\n                            paco21 + surv2md1 + resp1 + card + edu +\n                            age + race + sex),\n           data = md, weights = weights, family = quasibinomial)\n```\n:::\n\n\nThere is no value in examining this outcome model; the coefficients are uninterpretable and provide no information about the effects of the included predictors on the outcome. This model can be arbitrarily complicated and is not designed to be a useful predictive model for the outcome. Its sole purpose is to increase the precision of the resulting effect estimate. We will compute the marginal risks under treatment for each group and compute the risk ratio using g-computation. Here we specify arguments to `avg_predictions()` to use cluster-robust SEs that account for the matching and restrict the data to the treated units because we are estimating the ATT[^ex-match-3].\n\n[^ex-match-3]: In practice, it is okay to omit the `newdata` argument, especially when balance is excellent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"marginaleffects\")\n\navg_predictions(fit, variables = \"RHC\",\n                wts = \"weights\",\n                vcov = ~subclass,\n                newdata = subset(md, RHC == 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n RHC Estimate Pr(>|z|) 2.5 % 97.5 %\n   0    0.690   <0.001 0.656  0.722\n   1    0.713   <0.001 0.691  0.734\n\nColumns: RHC, estimate, p.value, conf.low, conf.high \n```\n:::\n:::\n\n\nWe find marginal risks of .69 and .713 for the treated units under control and treatment, respectively. We can compute the risk ratio using the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_comparisons(fit, variables = \"RHC\",\n                wts = \"weights\",\n                vcov = ~subclass,\n                newdata = subset(md, RHC == 1),\n                comparison = \"lnratioavg\",\n                transform = \"exp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n Term              Contrast Estimate Pr(>|z|) 2.5 % 97.5 %\n  RHC ln(mean(1) / mean(0))     1.04    0.138 0.989   1.09\n\nColumns: term, contrast, estimate, p.value, conf.low, conf.high, predicted, predicted_hi, predicted_lo \n```\n:::\n:::\n\n\nFrom this we find a risk ratio of 1.04, indicating that the risk of death is 4% higher for those receiving RHC than had they not received it. The confidence interval for the risk ratio is (.989, 1.09), and the p-value for the test that the log risk ratio is equal to 0 (i.e., that the risk ratio is equal to 1) is .138, indicating no evidence for an effect of RHC in either direction.\n\nTo report balance, we could include the final balance table above, a visual representation of it, or a summary of balance statistics (or combinations thereof). A clean visual representation of balance is in a Love plot, which can be requested as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlove.plot(m3, stats = c(\"m\", \"ks\"), binary = \"std\",\n          drop.distance = TRUE, abs = TRUE)\n```\n\n::: {.cell-output-display}\n![](ex-match_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nSee the `cobalt` [documentation](https://ngreifer.github.io/cobalt/) for more information on using `love.plot()` to make publication-ready plots.\n",
    "supporting": [
      "ex-match_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}